package com.wadpam.tracker.dao;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.blobstore.BlobstoreInputStream;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import static com.wadpam.tracker.dao.GeneratedDRaceDao.COLUMN_NAME_STARTDATE;
import com.wadpam.tracker.domain.DRace;
import com.wadpam.tracker.domain.TrackPoint;
import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import net.sf.mardao.core.Filter;
import net.sf.mardao.core.geo.Geobox;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * Implementation of Business Methods related to entity DRace.
 * This (empty) class is generated by mardao, but edited by developers.
 * It is not overwritten by the generator once it exists.
 *
 * Generated on 2014-01-24T20:26:57.207+0100.
 * @author mardao DAO generator (net.sf.mardao.plugin.ProcessDomainMojo)
 */
public class DRaceDaoBean 
	extends GeneratedDRaceDaoImpl
		implements DRaceDao 
{
    /** 2014-01-25T09:01:35.000Z */
    public static final SimpleDateFormat SDF = getDateFormat("GMT");
    
    public static SimpleDateFormat getDateFormat(String timeZone) {
        SimpleDateFormat sdf = new SimpleDateFormat(DATE_TIME_FORMAT);
        sdf.setTimeZone(TimeZone.getTimeZone(timeZone));
        return sdf;
    }
    
    @Override
    public TrackPoint findNearest(Object raceKey, long minTimestamp, Float lat, Float lon) {
        TrackPoint nearest = null;
        double dMin = Double.MAX_VALUE;
        DRace race = findByPrimaryKey(raceKey);
        
        for (TrackPoint p : getTrack(race.getBlobKey())) {
            if (minTimestamp <= p.getT()) {
                if (null == lat) {
                    return p;
                }
                double d = Geobox.distance(p.getLat(), p.getLon(), lat, lon);
                if (d < dMin) {
                    nearest = p;
                    dMin = d;
                }
            }
        }
        return nearest;
    }

    @Override
    public List<TrackPoint> getTrack(BlobKey blobKey) {
        MemcacheService memcache = MemcacheServiceFactory.getMemcacheService();
        
        List<TrackPoint> track = (List<TrackPoint>) memcache.get(blobKey.getKeyString());
        if (null == track) {
            track = parseTrack(blobKey);
            memcache.put(blobKey.getKeyString(), track);
        }
        
        return track;
    }

    private List<TrackPoint> parseTrack(BlobKey blobKey) {
        InputStream bis = null;
        try {
            final List<TrackPoint> track = new ArrayList<TrackPoint>();
            bis = new BlobstoreInputStream(blobKey);
            SAXParser parser = SAXParserFactory.newInstance().newSAXParser();
            DefaultHandler handler = new DefaultHandler() {

                private TrackPoint trkpt;
                private StringBuilder text = new StringBuilder();
                //private Object raceKey;
                private long startTime = 0l;
                private double distance = 0.0;
                private Float dLat = null, dLon = null;

                @Override
                public void startDocument() throws SAXException {
                }
                
                @Override
                public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
                    if ("trk".equalsIgnoreCase(qName)) {
                    }
                    else if ("trkpt".equalsIgnoreCase(qName)) {
                        trkpt = new TrackPoint();
                        float lat = Float.parseFloat(attributes.getValue("lat"));
                        float lon = Float.parseFloat(attributes.getValue("lon"));
                        trkpt.setLat(lat);
                        trkpt.setLon(lon);
                        
                        if (null == dLat) {
                        }
                        else {
                            double d = Geobox.distance(dLat, dLon, lat, lon);
                            distance += d;
                        }
                        trkpt.setD(Double.valueOf(distance).floatValue());
                        dLat = lat;
                        dLon = lon;
                        
                        //LOG.trace("Created trkpt for {}, {}", lat, lon);
                    }
                    else if ("ele".equalsIgnoreCase(qName) || "time".equalsIgnoreCase(qName)) {
                        text = new StringBuilder();
                    }
                }

                @Override
                public void characters(char[] ch, int start, int length) throws SAXException {
                    text.append(ch, start, length);
                }
                
                @Override
                public void endElement(String uri, String localName, String qName) throws SAXException {
                    if ("ele".equalsIgnoreCase(qName)) {
                        trkpt.setAlt(Float.valueOf(text.toString()));
                    }
                    // there can be a time tag within <metadata>
                    else if ("time".equalsIgnoreCase(qName) && null != trkpt) {
                        try {
                            Date t = SDF.parse(text.toString());
                            //LOG.info("time {} parsed into {}", text.toString(), t);
                            if (0l  == startTime) {
                                startTime = t.getTime();
                            }
                            trkpt.setT(t.getTime() - startTime);
                        } catch (ParseException ex) {
                            LOG.warn("time", ex);
                        }
                    }
                    else if ("trkpt".equalsIgnoreCase(qName)) {
                        track.add(trkpt);
                    }
                }

                
            };
            
            parser.parse(bis, handler);
            
            return track;
        } catch (ParserConfigurationException ex) {
            LOG.error("Creating parser", ex);
        } catch (SAXException ex) {
            LOG.error("Parsing", ex);
        } catch (IOException ex) {
            LOG.error("Error parsing track blob", ex);
        } finally {
            try {
                bis.close();
            } catch (IOException ex) {
            }
        }
        return null;
    }

    @Override
    public Iterable<Long> queryActive(Date now) {
        Date inOneMinute = new Date(now.getTime() + 60*1000);
        Date fourteenHoursAgo = new Date(now.getTime() - 14*60*60*1000);
        final Filter notExpired = createGreaterThanOrEqualFilter(COLUMN_NAME_STARTDATE, fourteenHoursAgo);
        final Filter hasStarted = new Filter(COLUMN_NAME_STARTDATE, Query.FilterOperator.LESS_THAN, inOneMinute);
        return queryIterableKeys(0, -1, null, null, COLUMN_NAME_STARTDATE, true, 
                null, false, hasStarted, notExpired);
    }


    @Override
    public Iterable<DRace> queryOpen(Date now) {
        Date inOneYear = new Date(now.getTime() + 300L*24L*60L*60L*1000L);
        Date fourteenHoursAgo = new Date(now.getTime() - 14*60*60*1000);
        final Filter notExpired = createGreaterThanOrEqualFilter(COLUMN_NAME_STARTDATE, fourteenHoursAgo);
        final Filter hasOpened = new Filter(COLUMN_NAME_STARTDATE, Query.FilterOperator.LESS_THAN, inOneYear);
        return queryIterable(false, 0, -1, null, null, COLUMN_NAME_STARTDATE, true, 
                null, false, hasOpened, notExpired);
    }

    
}
